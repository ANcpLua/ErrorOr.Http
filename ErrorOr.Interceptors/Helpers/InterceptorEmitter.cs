using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ErrorOr.Interceptors.Helpers;

internal static class InterceptorEmitter
{
    public static void Emit(
        SourceProductionContext spc,
        ImmutableArray<InterceptorGroup> groups,
        bool needsInterceptsAttr)
    {
        var code = new CodeBuilder();

        WriteFileHeader(code, needsInterceptsAttr);
        WriteInterceptors(code, groups);
        WriteErrorOrExtensions(code);

        code.AppendLine("}");

        spc.AddSource("ErrorOrInterceptors.g.cs", SourceText.From(code.ToString(), Encoding.UTF8));
    }

    private static void WriteFileHeader(CodeBuilder code, bool needsInterceptsAttr)
    {
        code.AppendLine("// <auto-generated/>");
        code.AppendLine("#nullable enable");
        code.AppendLine("using Microsoft.AspNetCore.Builder;"); // Needed for Map Extensions
        code.AppendLine("using Microsoft.AspNetCore.Http;"); // Needed for IResult/TypedResults
        code.AppendLine();

        if (needsInterceptsAttr)
        {
            code.AppendLine("#pragma warning disable CS9113");
            code.AppendLine("namespace System.Runtime.CompilerServices");
            code.AppendLine("{");
            code.Indent();
            code.AppendLine(
                "[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]");
            code.AppendLine(
                "file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute { }");
            code.Outdent();
            code.AppendLine("}");
            code.AppendLine("#pragma warning restore CS9113");
            code.AppendLine();
        }

        code.AppendLine("namespace ErrorOr.Interceptors.Generated");
        code.AppendLine("{");
        code.Indent();
        code.AppendLine("file static class ErrorOrInterceptors");
        code.AppendLine("{");
        code.Indent();
    }

    private static void WriteInterceptors(CodeBuilder code, ImmutableArray<InterceptorGroup> groups)
    {
        var methodIndex = 0;
        foreach (var group in groups)
        {
            var signature = group.Signature;
            var methodName = $"Map{signature.HttpMethod}_Intercepted_{methodIndex++}";

            foreach (var location in group.Locations.Items)
                code.AppendLine(location);

            WriteInterceptorMethod(code, signature, methodName);
            code.AppendLine();
        }
    }

    private static void WriteInterceptorMethod(CodeBuilder code, InterceptorSignature signature, string methodName)
    {
        var isNoContent = IsNoContentType(signature.SuccessTypeFqn);

        code.AppendLine($"public static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder {methodName}(");
        code.Indent();
        code.AppendLine("this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints,");
        code.AppendLine("string pattern,");
        code.AppendLine("global::System.Delegate handler)");
        code.Outdent();
        code.AppendLine("{");
        code.Indent();

        WriteInterceptorBody(code, signature, isNoContent);

        code.Outdent();
        code.AppendLine("}");
    }

    private static void WriteInterceptorBody(CodeBuilder code, InterceptorSignature signature, bool isNoContent)
    {
        var httpMethod = signature.HttpMethod;
        var successType = signature.SuccessTypeFqn;
        var inferredErrors = signature.InferredErrorTypes;
        int successStatus = isNoContent ? 204 : (httpMethod == "Post" ? 201 : 200);

        // 1. Call original Map method
        code.AppendLine($"return EndpointRouteBuilderExtensions.Map{httpMethod}(endpoints, pattern, handler)");

        // 2. Add Runtime Filter to unwrap ErrorOr<T> -> IResult
        code.AppendLine("    .AddEndpointFilter(async (context, next) =>");
        code.AppendLine("    {");
        code.Indent();
        code.AppendLine("var result = await next(context);");
        code.AppendLine($"if (result is global::ErrorOr.ErrorOr<{successType}> errorOr)");
        code.AppendLine("{");
        code.Indent();

        // Match ErrorOr result to HTTP responses
        code.AppendLine("return errorOr.Match<global::Microsoft.AspNetCore.Http.IResult>(");
        code.Indent();
        if (isNoContent)
            code.AppendLine("_ => TypedResults.NoContent(),");
        else
            code.AppendLine("value => TypedResults.Ok(value),");
        code.AppendLine("errors => ErrorOrExtensions.ToProblem(errors));");
        code.Outdent();

        code.Outdent();
        code.AppendLine("}");
        code.AppendLine("return result;");
        code.Outdent();
        code.AppendLine("    })");

        // 3. Add OpenAPI Metadata
        code.AppendLine(!isNoContent, $"    .Produces<{successType}>({successStatus})");

        if (!inferredErrors.IsDefaultOrEmpty)
        {
            foreach (var errorType in inferredErrors.Items)
            {
                var status = MapErrorTypeToHttpStatus(errorType);
                if (status == 400)
                    code.AppendLine("    .ProducesValidationProblem()");
                else
                    code.AppendLine($"    .ProducesProblem({status})");
            }
        }

        code.AppendLine("    ;");
    }

    private static void WriteErrorOrExtensions(CodeBuilder code)
    {
        code.Outdent();
        code.AppendLine("}");
        code.AppendLine();

        code.AppendLine("file static class ErrorOrExtensions");
        code.AppendLine("{");
        code.Indent();
        code.AppendLine("public static global::Microsoft.AspNetCore.Http.HttpResults.ProblemHttpResult ToProblem(");
        code.Indent();
        code.AppendLine("global::System.Collections.Generic.IReadOnlyList<global::ErrorOr.Error> errors)");
        code.Outdent();
        code.AppendLine("{");
        code.Indent();
        code.AppendLine("var first = errors.Count > 0 ? errors[0] : global::ErrorOr.Error.Unexpected();");
        code.AppendLine("var status = first.Type switch");
        code.AppendLine("{");
        code.Indent();
        code.AppendLine("global::ErrorOr.ErrorType.Validation => 400,");
        code.AppendLine("global::ErrorOr.ErrorType.Unauthorized => 401,");
        code.AppendLine("global::ErrorOr.ErrorType.Forbidden => 403,");
        code.AppendLine("global::ErrorOr.ErrorType.NotFound => 404,");
        code.AppendLine("global::ErrorOr.ErrorType.Conflict => 409,");
        code.AppendLine("global::ErrorOr.ErrorType.Failure => 422,");
        code.AppendLine("_ => 500");
        code.Outdent();
        code.AppendLine("};");
        code.AppendLine("return global::Microsoft.AspNetCore.Http.TypedResults.Problem(");
        code.Indent();
        code.AppendLine("detail: first.Description,");
        code.AppendLine("statusCode: status,");
        code.AppendLine("title: first.Code);");
        code.Outdent();
        code.Outdent();
        code.AppendLine("}");
        code.Outdent();
        code.AppendLine("}");
    }

    private static bool IsNoContentType(string typeFqn) =>
        typeFqn.EndsWith("Deleted") || typeFqn.EndsWith("Success");

    private static int MapErrorTypeToHttpStatus(int errorType) =>
        errorType switch { 2 => 400, 3 => 409, 4 => 404, 5 => 401, 6 => 403, 0 => 422, _ => 500 };
}