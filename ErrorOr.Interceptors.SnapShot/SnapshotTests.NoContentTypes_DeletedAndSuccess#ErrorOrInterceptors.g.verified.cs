//HintName: ErrorOrInterceptors.g.cs
// <auto-generated/>
#nullable enable
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;

#pragma warning disable CS9113
namespace System.Runtime.CompilerServices
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute { }
}
#pragma warning restore CS9113

namespace ErrorOr.Interceptors.Generated
{
    file static class ErrorOrInterceptors
    {
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "5l2i7wzNK62NcFk8Df2uR4IAAAA=")]
        public static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapDelete_Intercepted_0(
            this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints,
            string pattern,
            global::System.Delegate handler)
        {
            return EndpointRouteBuilderExtensions.MapDelete(endpoints, pattern, handler)
                .AddEndpointFilter(async (context, next) =>
                {
                var result = await next(context);
                if (result is global::ErrorOr.ErrorOr<global::ErrorOr.Deleted> errorOr)
                {
                    return errorOr.Match<global::Microsoft.AspNetCore.Http.IResult>(
                        _ => TypedResults.NoContent(),
                        errors => ErrorOrExtensions.ToProblem(errors));
                }
                return result;
                })
                .ProducesProblem(404)
                ;
        }

        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "5l2i7wzNK62NcFk8Df2uRxQBAAA=")]
        public static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapPost_Intercepted_1(
            this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints,
            string pattern,
            global::System.Delegate handler)
        {
            return EndpointRouteBuilderExtensions.MapPost(endpoints, pattern, handler)
                .AddEndpointFilter(async (context, next) =>
                {
                var result = await next(context);
                if (result is global::ErrorOr.ErrorOr<global::ErrorOr.Success> errorOr)
                {
                    return errorOr.Match<global::Microsoft.AspNetCore.Http.IResult>(
                        _ => TypedResults.NoContent(),
                        errors => ErrorOrExtensions.ToProblem(errors));
                }
                return result;
                })
                .ProducesValidationProblem()
                ;
        }

    }

    file static class ErrorOrExtensions
    {
        public static global::Microsoft.AspNetCore.Http.HttpResults.ProblemHttpResult ToProblem(
            global::System.Collections.Generic.IReadOnlyList<global::ErrorOr.Error> errors)
        {
            var first = errors.Count > 0 ? errors[0] : global::ErrorOr.Error.Unexpected();
            var status = first.Type switch
            {
                global::ErrorOr.ErrorType.Validation => 400,
                global::ErrorOr.ErrorType.Unauthorized => 401,
                global::ErrorOr.ErrorType.Forbidden => 403,
                global::ErrorOr.ErrorType.NotFound => 404,
                global::ErrorOr.ErrorType.Conflict => 409,
                global::ErrorOr.ErrorType.Failure => 422,
                _ => 500
            };
            return global::Microsoft.AspNetCore.Http.TypedResults.Problem(
                detail: first.Description,
                statusCode: status,
                title: first.Code);
        }
    }
    }
